<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat.js Oluşturma Fonksiyonları Raporu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #fffbeb; /* Amber 50 arka plan */
        }
        .function-section {
            background-color: #ffffff;
            border-radius: 0.75rem; /* 12px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 2rem; /* 32px */
            padding: 1.5rem; /* 24px */
            border-left: 4px solid #f59e0b; /* Amber 500 kenarlık */
        }
        .function-title-text {
            color: #b45309; /* Amber 700 */
            font-weight: 600; /* Yarı kalın */
        }
        .code-block { 
            background-color: #1e293b; /* Gri 800 */
            color: #e2e8f0; /* Gri 200 */
            padding: 1rem; /* 16px */
            border-radius: 0.5rem; /* 8px */
            margin-top: 1rem; /* 16px */
            margin-bottom: 1rem; /* 16px */
            white-space: pre-wrap; 
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.875rem; /* 14px */
            line-height: 1.5; 
            overflow-x: auto; 
        }
        .explanation-summary {
            background-color: #fffbeb; /* Amber 50 */
            padding: 0.75rem 1rem; /* 12px 16px */
            border-radius: 0.5rem; /* 8px */
            margin-bottom: 0.5rem; /* 8px */
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #92400e; /* Amber 800 */
            font-weight: 500; /* Orta */
            border: 1px solid #fde68a; /* Amber 200 */
        }
        .explanation-summary:hover {
            background-color: #fef3c7; /* Amber 100 */
        }
        .explanation-details { 
            margin-left: 1rem; /* 16px */
            padding-left: 1rem; /* 16px */
            border-left: 3px solid #fcd34d; /* Amber 300 */
            padding-top: 0.5rem; /* 8px */
            padding-bottom: 0.5rem; /* 8px */
            color: #374151; /* Gri 700 */
        }
        .explanation-details p {
            margin-bottom: 0.75rem; /* 12px */
        }
        .explanation-details strong {
            color: #1f2937; /* Gri 800 */
        }
        details > summary { 
            list-style: none; 
        }
        details > summary::-webkit-details-marker { 
            display: none; 
        }
        details > summary::marker { 
            display: none; 
        }
        .chevron::before {
            border-style: solid;
            border-width: 0.15em 0.15em 0 0;
            content: '';
            display: inline-block;
            height: 0.45em;
            left: 0.15em;
            position: relative;
            top: 0.15em;
            transform: rotate(-45deg);
            vertical-align: top;
            width: 0.45em;
            transition: transform 0.2s ease-in-out;
        }
        details[open] > summary .chevron::before {
            transform: rotate(135deg);
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-5xl mx-auto bg-white shadow-xl rounded-xl p-6 md:p-8">
        <header class="mb-8 pb-6 border-b border-gray-300">
            <h1 class="text-4xl font-bold text-center text-amber-700"><code>chat.js</code> Oluşturma Fonksiyonları Raporu</h1>
            <p class="text-center text-gray-600 mt-3 text-lg"><code>chat.js</code> dosyasının "Oluşturma Fonksiyonları" (Rendering Functions) olarak adlandırılan bölümündeki fonksiyonların ve komutlarının detaylı açıklaması.</p>
        </header>

        <section id="rendering-functions-overview" class="mb-10 p-6 bg-amber-50 rounded-lg border border-amber-200">
            <h2 class="text-2xl font-semibold text-amber-600 mb-3">3. Oluşturma Fonksiyonları (Rendering Functions)</h2>
            <p class="text-gray-700 leading-relaxed">
                Bu bölüm, uygulamanın kullanıcı arayüzünün (UI) dinamik olarak nasıl oluşturulduğunu ve güncellendiğini yöneten fonksiyonları içerir. 
                Aktif sohbet pencerelerinin, kenar çubuğundaki aktif sohbetler listesinin ve sohbet geçmişi listesinin görünümünü yönetirler. 
                Bu fonksiyonlar, uygulama durumu (state) değiştikçe arayüzün tutarlı ve güncel kalmasını sağlar.
            </p>
        </section>

        <section class="function-section" id="render-chats">
            <h3 class="text-xl function-title-text mb-3">3.1 Sohbet Pencereleri (Chat Windows)</h3>
            <p class="text-gray-600 mb-4"><code>renderChats()</code> fonksiyonu, aktif sohbet pencerelerini ana sohbet alanında oluşturur ve düzenler. Sohbet sayısına göre farklı yerleşim düzenleri uygular ve hiç aktif sohbet olmadığında veya tüm sohbetler küçültüldüğünde bir karşılama ekranı gösterir.</p>
            
            <h4 class="text-lg font-semibold text-gray-700 mt-4">Fonksiyon: <code>renderChats()</code></h4>
            <div class="code-block">
function renderChats() {
    log('debug', 'Rendering chats. Current state:', JSON.parse(JSON.stringify(state.chats)));
    
    if (!elements.chatContainer) {
        log('error', 'Cannot render chats: chat container not found');
        return;
    }
    
    elements.chatContainer.innerHTML = '';
    
    if (state.chats.length === 0) {
        elements.chatContainer.appendChild(elements.welcomeScreen);
        return;
    }
    
    if (elements.welcomeScreen.parentNode) {
        elements.welcomeScreen.parentNode.removeChild(elements.welcomeScreen);
    }
    
    let layoutClass;
    const activeChats = state.chats.filter(chat => !chat.isMinimized);

    if (activeChats.length === 0 && state.chats.length > 0) {
        elements.chatContainer.appendChild(elements.welcomeScreen);
        elements.chatContainer.className = 'flex-grow-1 d-flex flex-wrap'; 
        return;
    } else if (state.chats.length === 0) {
        elements.chatContainer.appendChild(elements.welcomeScreen);
        elements.chatContainer.className = 'flex-grow-1 d-flex flex-wrap'; 
        return;
    }

    switch (activeChats.length) {
        case 1: layoutClass = 'layout-1'; break;
        case 2: layoutClass = 'layout-2'; break;
        case 3: layoutClass = 'layout-3'; break;
        case 4: layoutClass = 'layout-4'; break;
        case 5: layoutClass = 'layout-5'; break;
        case 6: layoutClass = 'layout-6'; break;
        default: layoutClass = 'layout-6'; break;
    }
    
    elements.chatContainer.className = \`flex-grow-1 d-flex flex-wrap ${layoutClass}\`;
    
    activeChats.forEach(chatData => {
        const chatElement = createChatElement(chatData);
        elements.chatContainer.appendChild(chatElement);
        setupChatControls(chatElement);
    });
    renderActiveChatsDropdown();
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>log('debug', 'Rendering chats. Current state:', JSON.parse(JSON.stringify(state.chats)));</code></strong>: Fonksiyonun çağrıldığını ve o anki <code>state.chats</code> (aktif sohbetler) durumunu (derin bir kopyasını alarak) loglar. Bu, hata ayıklama için sohbetlerin mevcut durumunu görmeyi sağlar.</p>
                    <p><strong><code>if (!elements.chatContainer) { ... }</code></strong>: <code>elements.chatContainer</code> DOM elemanının (sohbet pencerelerinin yerleştirileceği ana kapsayıcı) var olup olmadığını kontrol eder. Yoksa hata loglar ve fonksiyondan çıkar.</p>
                    <p><strong><code>elements.chatContainer.innerHTML = '';</code></strong>: Sohbet kapsayıcısının mevcut içeriğini temizler. Bu, pencereleri yeniden oluşturmadan önce eski pencerelerin kaldırılmasını sağlar.</p>
                    <p><strong><code>if (state.chats.length === 0) { ... }</code></strong>: Eğer hiç aktif sohbet (<code>state.chats</code> dizisi boşsa) yoksa, karşılama ekranını (<code>elements.welcomeScreen</code>) sohbet kapsayıcısına ekler ve fonksiyondan çıkar.</p>
                    <p><strong><code>if (elements.welcomeScreen.parentNode) { ... }</code></strong>: Eğer karşılama ekranı DOM'da mevcutsa (yani bir ebeveyni varsa), onu DOM'dan kaldırır. Bu, aktif sohbetler olduğunda karşılama ekranının gizlenmesini sağlar.</p>
                    <p><strong><code>let layoutClass;</code></strong>: Sohbet pencerelerinin yerleşim düzenini belirleyecek CSS sınıfını tutmak için bir değişken tanımlar.</p>
                    <p><strong><code>const activeChats = state.chats.filter(chat => !chat.isMinimized);</code></strong>: <code>state.chats</code> dizisinden sadece küçültülmemiş (<code>isMinimized</code> özelliği <code>false</code> olan) sohbetleri filtreleyerek yeni bir <code>activeChats</code> dizisi oluşturur.</p>
                    <p><strong><code>if (activeChats.length === 0 && state.chats.length > 0) { ... }</code></strong>: Eğer hiç aktif (küçültülmemiş) sohbet yoksa ama genel olarak sohbetler varsa (yani tüm sohbetler küçültülmüşse), karşılama ekranını gösterir ve varsayılan bir kapsayıcı sınıfı ayarlar, ardından fonksiyondan çıkar.</p>
                    <p><strong><code>else if (state.chats.length === 0) { ... }</code></strong>: (Bu koşul aslında yukarıdaki <code>state.chats.length === 0</code> ile aynıdır ve biraz gereksizdir, ancak kodda mevcut.) Hiç sohbet yoksa karşılama ekranını gösterir.</p>
                    <p><strong><code>switch (activeChats.length) { ... }</code></strong>: Aktif (küçültülmemiş) sohbet sayısına göre <code>layoutClass</code> değişkenine uygun CSS sınıfını atar (örn: 1 sohbet için <code>layout-1</code>, 2 sohbet için <code>layout-2</code>, vb.). Bu sınıflar, sohbet pencerelerinin ekranda nasıl düzenleneceğini belirler.</p>
                    <p><strong><code>elements.chatContainer.className = \`flex-grow-1 d-flex flex-wrap ${layoutClass}\`;</code></strong>: Sohbet kapsayıcısının CSS sınıflarını ayarlar. Temel flexbox sınıflarına ek olarak, belirlenen <code>layoutClass</code>'ı da ekler.</p>
                    <p><strong><code>activeChats.forEach(chatData => { ... });</code></strong>: Her bir aktif (küçültülmemiş) sohbet (<code>chatData</code>) için bir döngü başlatır.</p>
                    <ul>
                        <li><strong><code>const chatElement = createChatElement(chatData);</code></strong>: Her bir sohbet verisi için <code>createChatElement</code> fonksiyonunu (UI Bileşenleri bölümünden) çağırarak bir sohbet penceresi DOM elemanı oluşturur.</li>
                        <li><strong><code>elements.chatContainer.appendChild(chatElement);</code></strong>: Oluşturulan sohbet penceresi elemanını ana sohbet kapsayıcısına ekler.</li>
                        <li><strong><code>setupChatControls(chatElement);</code></strong>: Yeni oluşturulan sohbet penceresi elemanındaki kontrol düğmeleri (kapat, küçült vb.) için olay dinleyicilerini ayarlayan <code>setupChatControls</code> fonksiyonunu çağırır.</li>
                    </ul>
                    <p><strong><code>renderActiveChatsDropdown();</code></strong>: Kenar çubuğundaki aktif sohbetler açılır menüsünü günceller.</p>
                </div>
            </details>
        </section>

        <section class="function-section" id="render-active-chats-dropdown">
            <h3 class="text-xl function-title-text mb-3">3.2 Aktif Sohbetler Açılır Menüsü (Active Chats Dropdown)</h3>
            <p class="text-gray-600 mb-4"><code>renderActiveChatsDropdown()</code> fonksiyonu, kenar çubuğunda bulunan ve tüm aktif sohbetleri listeleyen açılır menüyü oluşturur. Küçültülmüş sohbetleri geri yükleme veya aktif sohbetleri vurgulama gibi işlevler sunar.</p>

            <h4 class="text-lg font-semibold text-gray-700 mt-4">Fonksiyon: <code>renderActiveChatsDropdown()</code></h4>
            <div class="code-block">
function renderActiveChatsDropdown() {
    if (!elements.activeChatsList || !elements.activeChatsDropdownMenu || !elements.activeChatsDropdownTrigger) {
        log('warn', 'Active chats dropdown elements not found');
        return;
    }

    elements.activeChatsList.innerHTML = ''; 

    if (state.chats.length === 0) {
        elements.activeChatsDropdownTrigger.classList.add('disabled');
        elements.activeChatsDropdownMenu.classList.remove('show'); 
        const noChatsLi = document.createElement('li');
        noChatsLi.className = 'list-group-item text-muted';
        noChatsLi.textContent = 'No active chats';
        noChatsLi.style.paddingLeft = '1rem';
        elements.activeChatsList.appendChild(noChatsLi);
        elements.activeChatsDropdownTrigger.setAttribute('aria-expanded', 'false');
        return;
    }
    
    elements.activeChatsDropdownTrigger.classList.remove('disabled');

    state.chats.forEach(chatData => {
        const aiModel = window.state.aiTypes.find(m => m.id === chatData.aiModelId) || { name: \`AI (${chatData.aiModelId ? chatData.aiModelId.slice(-4) : 'Unknown'})\`, icon: 'bi bi-cpu' };
        const listItem = document.createElement('li');
        listItem.className = 'list-group-item list-group-item-action active-chat-item d-flex align-items-center justify-content-between';
        listItem.setAttribute('data-chat-id', chatData.id);
        // ... (stil ve içerik atamaları) ...

        if (chatData.isMinimized) {
            // ... (küçültülmüş sohbetler için mantık) ...
            listItem.onclick = (e) => {
                e.stopPropagation(); 
                const chatToRestore = state.chats.find(c => c.id === chatData.id);
                if (chatToRestore) {
                    chatToRestore.isMinimized = false;
                    renderChats();
                    renderActiveChatsDropdown();
                }
            };
        } else {
            // ... (aktif sohbetler için mantık) ...
            listItem.onclick = () => {
                log('action', \`Active chat item clicked: ${chatData.id}. Highlighting chat window.\`);
                const chatWindow = document.querySelector(\`.chat-window[data-chat-id="${chatData.id}"]\`);
                if (chatWindow) {
                    chatWindow.classList.add('chat-window--highlighted');
                    setTimeout(() => {
                        chatWindow.classList.remove('chat-window--highlighted');
                    }, 2000); 
                }
            };
        }
        elements.activeChatsList.appendChild(listItem);
    });
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları (Özetlenmiş)</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>if (!elements.activeChatsList || ...) { ... }</code></strong>: Aktif sohbetler açılır menüsü için gerekli DOM elemanlarının (liste, menü, tetikleyici) var olup olmadığını kontrol eder. Yoksa uyarı loglar ve çıkar.</p>
                    <p><strong><code>elements.activeChatsList.innerHTML = '';</code></strong>: Mevcut aktif sohbet listesini temizler.</p>
                    <p><strong><code>if (state.chats.length === 0) { ... }</code></strong>: Eğer hiç aktif sohbet yoksa, açılır menü tetikleyicisini devre dışı bırakır, menüyü gizler ve "No active chats" (Aktif sohbet yok) mesajını gösteren bir liste öğesi ekler.</p>
                    <p><strong><code>elements.activeChatsDropdownTrigger.classList.remove('disabled');</code></strong>: Aktif sohbetler varsa, açılır menü tetikleyicisinin devre dışı bırakılmış durumunu kaldırır.</p>
                    <p><strong><code>state.chats.forEach(chatData => { ... });</code></strong>: Her bir aktif sohbet (<code>chatData</code>) için bir döngü başlatır.</p>
                    <ul>
                        <li><strong><code>const aiModel = ...;</code></strong>: Sohbetin yapay zeka model bilgilerini alır (<code>createChatElement</code> fonksiyonundakine benzer bir mantıkla).</p>
                        <li><strong><code>const listItem = document.createElement('li');</code></strong>: Her sohbet için bir liste öğesi (<code>&lt;li&gt;</code>) oluşturur.</p>
                        <li><strong><code>listItem.className = ...; listItem.setAttribute(...);</code></strong>: Liste öğesine CSS sınıfları ve <code>data-chat-id</code> niteliği atar.</p>
                        <li><strong><code>chatNameHTML = \`...\`;</code></strong>: Sohbetin adını ve ikonunu içeren HTML'i oluşturur.</p>
                        <li><strong><code>if (chatData.isMinimized) { ... }</code></strong>: Eğer sohbet küçültülmüşse:
                            <ul>
                                <li>Liste öğesine "küçültülmüş" olduğunu belirten bir sınıf ekler.</li>
                                <li>İçeriğine bir "geri yükle" ikonu ekler.</li>
                                <li>Tıklandığında, sohbetin <code>isMinimized</code> durumunu <code>false</code> yapar ve arayüzü (<code>renderChats</code>, <code>renderActiveChatsDropdown</code>) günceller.</li>
                            </ul>
                        </li>
                        <li><strong><code>else { ... }</code></strong>: Eğer sohbet küçültülmemişse:
                            <ul>
                                <li>Tıklandığında, ilgili sohbet penceresini ana alanda 2 saniyeliğine vurgular (<code>chat-window--highlighted</code> sınıfını ekleyip kaldırarak).</li>
                            </ul>
                        </li>
                        <li><strong><code>elements.activeChatsList.appendChild(listItem);</code></strong>: Oluşturulan liste öğesini aktif sohbetler listesine ekler.</li>
                    </ul>
                </div>
            </details>
        </section>

        <section class="function-section" id="render-chat-history">
            <h3 class="text-xl function-title-text mb-3">3.3 Sohbet Geçmişi (Chat History)</h3>
            <p class="text-gray-600 mb-4"><code>renderChatHistory()</code> fonksiyonu, kenar çubuğunda bulunan ve kapatılmış (ancak mesaj içeren) sohbetleri listeleyen bölümü oluşturur. Kullanıcıların geçmiş sohbetleri görmesini ve potansiyel olarak geri yüklemesini sağlar (geri yükleme işlevi "TODO" olarak işaretlenmiştir).</p>

            <h4 class="text-lg font-semibold text-gray-700 mt-4">Fonksiyon: <code>renderChatHistory()</code></h4>
            <div class="code-block">
function renderChatHistory() {
    if (!elements.chatHistoryList || !elements.chatHistoryTrigger || !elements.chatHistoryMenu) {
        log('warn', 'Chat history elements not found in DOM.');
        return;
    }

    elements.chatHistoryList.innerHTML = ''; 

    if (state.chatHistory.length === 0) {
        elements.chatHistoryTrigger.classList.add('disabled');
        elements.chatHistoryMenu.classList.remove('show'); 
        const noHistoryLi = document.createElement('li');
        noHistoryLi.className = 'list-group-item text-muted';
        noHistoryLi.textContent = 'No chat history';
        // ... (stil ve içerik atamaları) ...
        elements.chatHistoryList.appendChild(noHistoryLi);
        elements.chatHistoryTrigger.setAttribute('aria-expanded', 'false');
        return;
    }

    elements.chatHistoryTrigger.classList.remove('disabled');

    state.chatHistory.forEach(chat => {
        const aiType = state.aiTypes.find(ai => ai.id === chat.aiType) || { name: 'Unknown AI', icon: 'bi bi-archive' };
        const listItem = document.createElement('li');
        // ... (sınıf, nitelik ve stil atamaları) ...
        
        // ... (isim ve ikon için HTML oluşturma) ...

        const restoreButton = document.createElement('button');
        // ... (geri yükleme butonu için sınıf, başlık, ikon ve olay dinleyici atamaları) ...
        restoreButton.onclick = function(event) {
            event.stopPropagation();
            log('action', 'Restore chat from history clicked (not implemented yet)', chat.id);
            alert('Restoring chat from history is not yet implemented.');
            // TODO: Implement restoreChatFromHistory(chat.id);
        };
        listItem.appendChild(restoreButton);

        listItem.onclick = function() {
            log('action', 'Chat history item clicked', chat.id);
            alert(\`Displaying history for chat ${chat.id} is not yet implemented. Messages: ${JSON.stringify(chat.messages)}\`);
            // TODO: Implement logic to display chat history messages
        };

        elements.chatHistoryList.appendChild(listItem);
    });
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları (Özetlenmiş)</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>if (!elements.chatHistoryList || ...) { ... }</code></strong>: Sohbet geçmişi için gerekli DOM elemanlarının (liste, tetikleyici, menü) var olup olmadığını kontrol eder. Yoksa uyarı loglar ve çıkar.</p>
                    <p><strong><code>elements.chatHistoryList.innerHTML = '';</code></strong>: Mevcut sohbet geçmişi listesini temizler.</p>
                    <p><strong><code>if (state.chatHistory.length === 0) { ... }</code></strong>: Eğer sohbet geçmişi boşsa, geçmiş tetikleyicisini devre dışı bırakır, menüyü gizler ve "No chat history" (Sohbet geçmişi yok) mesajını gösteren bir liste öğesi ekler.</p>
                    <p><strong><code>elements.chatHistoryTrigger.classList.remove('disabled');</code></strong>: Sohbet geçmişi varsa, tetikleyicinin devre dışı bırakılmış durumunu kaldırır.</p>
                    <p><strong><code>state.chatHistory.forEach(chat => { ... });</code></strong>: Sohbet geçmişindeki her bir <code>chat</code> öğesi için bir döngü başlatır.</p>
                    <ul>
                        <li><strong><code>const aiType = ...;</code></strong>: Geçmişteki sohbetin yapay zeka tipi bilgilerini alır.</p>
                        <li><strong><code>const listItem = document.createElement('li');</code></strong>: Her geçmiş sohbet için bir liste öğesi oluşturur.</p>
                        <li>CSS sınıfları, <code>data-chat-id</code> niteliği ve diğer stiller atanır.</p>
                        <li>Sohbetin adı, ikonu ve kapatılma tarihi (eğer varsa) ile birlikte HTML içeriği oluşturulur.</p>
                        <li><strong><code>const restoreButton = document.createElement('button');</code></strong>: Bir "Geri Yükle" butonu oluşturulur.</p>
                        <ul>
                            <li>Butona stil, başlık ve ikon eklenir.</li>
                            <li>Tıklandığında, bir log mesajı ve henüz uygulanmadığını belirten bir <code>alert</code> gösterir. <code>// TODO: Implement restoreChatFromHistory(chat.id);</code> yorumu, bu işlevselliğin gelecekte ekleneceğini belirtir.</li>
                        </ul>
                        </li>
                        <li>Liste öğesinin kendisine tıklandığında, bir log mesajı ve geçmiş mesajlarını gösterme işlevinin henüz uygulanmadığını belirten bir <code>alert</code> gösterir. <code>// TODO: Implement logic to display chat history messages</code> yorumu, bu işlevselliğin gelecekte ekleneceğini belirtir.</li>
                        <li><strong><code>elements.chatHistoryList.appendChild(listItem);</code></strong>: Oluşturulan liste öğesini sohbet geçmişi listesine ekler.</li>
                    </ul>
                </div>
            </details>
        </section>

    </div>
</body>
</html>
