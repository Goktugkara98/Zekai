<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat.js Sohbet İşlemleri Fonksiyon Raporu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f0fdfa; /* Teal 50 arka plan */
        }
        .function-section {
            background-color: #ffffff;
            border-radius: 0.75rem; /* 12px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 2rem; /* 32px */
            padding: 1.5rem; /* 24px */
            border-left: 4px solid #0d9488; /* Teal 600 kenarlık */
        }
        .function-title-text {
            color: #0f766e; /* Teal 700 */
            font-weight: 600; /* Yarı kalın */
        }
        .code-block { 
            background-color: #1e293b; /* Gri 800 */
            color: #e2e8f0; /* Gri 200 */
            padding: 1rem; /* 16px */
            border-radius: 0.5rem; /* 8px */
            margin-top: 1rem; /* 16px */
            margin-bottom: 1rem; /* 16px */
            white-space: pre-wrap; 
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.875rem; /* 14px */
            line-height: 1.5; 
            overflow-x: auto; 
        }
        .explanation-summary {
            background-color: #ccfbf1; /* Teal 100 */
            padding: 0.75rem 1rem; /* 12px 16px */
            border-radius: 0.5rem; /* 8px */
            margin-bottom: 0.5rem; /* 8px */
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #115e59; /* Teal 800 */
            font-weight: 500; /* Orta */
            border: 1px solid #99f6e4; /* Teal 200 */
        }
        .explanation-summary:hover {
            background-color: #5eead4; /* Teal 300 */
        }
        .explanation-details { 
            margin-left: 1rem; /* 16px */
            padding-left: 1rem; /* 16px */
            border-left: 3px solid #2dd4bf; /* Teal 400 */
            padding-top: 0.5rem; /* 8px */
            padding-bottom: 0.5rem; /* 8px */
            color: #374151; /* Gri 700 */
        }
        .explanation-details p {
            margin-bottom: 0.75rem; /* 12px */
        }
        .explanation-details strong {
            color: #1f2937; /* Gri 800 */
        }
        details > summary { 
            list-style: none; 
        }
        details > summary::-webkit-details-marker { 
            display: none; 
        }
        details > summary::marker { 
            display: none; 
        }
        .chevron::before {
            border-style: solid;
            border-width: 0.15em 0.15em 0 0;
            content: '';
            display: inline-block;
            height: 0.45em;
            left: 0.15em;
            position: relative;
            top: 0.15em;
            transform: rotate(-45deg);
            vertical-align: top;
            width: 0.45em;
            transition: transform 0.2s ease-in-out;
        }
        details[open] > summary .chevron::before {
            transform: rotate(135deg);
        }
        .api-call {
            background-color: #e0f2fe; /* Sky 100 */
            border-left: 4px solid #0ea5e9; /* Sky 500 */
            padding: 0.75rem;
            margin-top: 0.5rem;
            border-radius: 0.25rem;
            font-style: italic;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-5xl mx-auto bg-white shadow-xl rounded-xl p-6 md:p-8">
        <header class="mb-8 pb-6 border-b border-gray-300">
            <h1 class="text-4xl font-bold text-center text-teal-700"><code>chat.js</code> Sohbet İşlemleri Fonksiyon Raporu</h1>
            <p class="text-center text-gray-600 mt-3 text-lg"><code>chat.js</code> dosyasının "Sohbet İşlemleri" (Chat Operations) olarak adlandırılan bölümündeki fonksiyonların ve komutlarının detaylı açıklaması.</p>
        </header>

        <section id="chat-operations-overview" class="mb-10 p-6 bg-teal-50 rounded-lg border border-teal-200">
            <h2 class="text-2xl font-semibold text-teal-600 mb-3">5. Sohbet İşlemleri (Chat Operations)</h2>
            <p class="text-gray-700 leading-relaxed">
                Bu bölüm, sohbet uygulamasının temel işlevselliğini yöneten fonksiyonları içerir. 
                Yeni sohbet pencerelerinin oluşturulması, mevcut sohbetlerin kaldırılması, kullanılmayan sohbetlerin temizlenmesi, 
                kullanıcı ve yapay zeka mesajlarının gönderilip alınması ve tüm aktif sohbetlere toplu mesaj gönderilmesi 
                gibi kritik işlemleri kapsar.
            </p>
        </section>

        <section class="function-section" id="chat-management">
            <h3 class="text-xl function-title-text mb-3">5.1 Sohbet Yönetimi (Chat Management)</h3>
            <p class="text-gray-600 mb-4">Bu alt bölüm, sohbet pencerelerinin eklenmesi, kaldırılması ve temizlenmesiyle ilgili fonksiyonları içerir.</p>
            
            <h4 class="text-lg font-semibold text-gray-700 mt-4">Fonksiyon: <code>addChat(aiModelId)</code></h4>
            <div class="code-block">
function addChat(aiModelId) {
    log('action', 'Attempting to add new chat. Requested AI Model ID:', aiModelId);

    if (!elements.chatContainer) {
        log('error', 'Chat container not found. Cannot add chat.');
        ModalManager.showAlert('Error: Chat container not found.'); // Varsayılan ModalManager kullanımı
        return null;
    }

    if (state.chats.length >= state.maxChats) {
        log('warn', \`Max chats reached (${state.maxChats}). Cannot add new chat.\`);
        ModalManager.showAlert(\`Maximum of ${state.maxChats} chat panels reached. Please close one first.\`);
        return null;
    }

    let finalAiModelId = aiModelId;
    if (!finalAiModelId) {
        if (window.state && window.state.aiTypes && window.state.aiTypes.length > 0) {
            finalAiModelId = window.state.aiTypes[0].id; 
            log('info', 'No AI Model ID provided, defaulting to first in list:', finalAiModelId);
        } else {
            log('error', 'addChat: No AI Model ID provided and no default AI available from window.state.aiTypes.');
            ModalManager.showAlert('Cannot create chat: No AI models available or AI models not loaded yet.');
            return null;
        }
    } else {
        const modelExists = window.state.aiTypes.some(m => m.id === finalAiModelId);
        if (!modelExists) {
            log('warn', \`addChat: Provided AI Model ID "${finalAiModelId}" does not exist... Defaulting to first AI.\`);
            if (window.state && window.state.aiTypes && window.state.aiTypes.length > 0) {
                finalAiModelId = window.state.aiTypes[0].id;
            } else {
                log('error', 'addChat: Provided AI Model ID was invalid and no fallback AI available.');
                ModalManager.showAlert('Cannot create chat: Specified AI model is invalid and no fallback available.');
                return null;
            }
        }
    }
    
    const newChat = {
        id: \`chat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}\`,
        aiModelId: finalAiModelId,
        messages: [],
        createdAt: Date.now(),
        lastActivity: Date.now(),
        isMinimized: false,
        inputHistory: [], 
        historyIndex: -1   
    };

    state.chats.push(newChat);
    log('info', 'New chat added:', JSON.parse(JSON.stringify(newChat)));
    
    renderChats(); 
    renderActiveChatsDropdown(); 

    const newChatElement = elements.chatContainer.querySelector(\`[data-chat-id="${newChat.id}"]\`);
    if (newChatElement) {
        const inputField = newChatElement.querySelector('.chat-input');
        if (inputField && newChatElement.offsetParent !== null) {
           inputField.focus();
        }
    }
    return newChat.id;
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>log('action', ...);</code></strong>: Yeni bir sohbet ekleme girişimini ve istenen AI model ID'sini loglar.</p>
                    <p><strong><code>if (!elements.chatContainer) { ... }</code></strong>: Sohbet kapsayıcısının var olup olmadığını kontrol eder. Yoksa hata loglar, kullanıcıya bir uyarı gösterir (<code>ModalManager.showAlert</code> varsayımsal bir modal yöneticisidir) ve <code>null</code> döner.</p>
                    <p><strong><code>if (state.chats.length >= state.maxChats) { ... }</code></strong>: Mevcut sohbet sayısının maksimum limite ulaşıp ulaşmadığını kontrol eder. Ulaşmışsa uyarı loglar, kullanıcıya bilgi verir ve <code>null</code> döner.</p>
                    <p><strong><code>let finalAiModelId = aiModelId;</code></strong>: Kullanılacak AI model ID'sini tutmak için bir değişken başlatır.</p>
                    <p><strong><code>if (!finalAiModelId) { ... }</code></strong>: Eğer fonksiyona bir <code>aiModelId</code> sağlanmamışsa:</p>
                    <ul>
                        <li><strong><code>if (window.state && window.state.aiTypes && window.state.aiTypes.length > 0)</code></strong>: Global durumda AI tipleri listesi varsa ve boş değilse, ilk AI modelinin ID'sini varsayılan olarak kullanır.</li>
                        <li><strong><code>else { ... }</code></strong>: Varsayılan AI modeli bulunamazsa hata loglar, kullanıcıya bilgi verir ve <code>null</code> döner.</li>
                    </ul>
                    <p><strong><code>else { ... }</code></strong>: Eğer bir <code>aiModelId</code> sağlanmışsa:</p>
                    <ul>
                        <li><strong><code>const modelExists = window.state.aiTypes.some(m => m.id === finalAiModelId);</code></strong>: Sağlanan ID'nin geçerli bir AI modeline ait olup olmadığını kontrol eder.</li>
                        <li><strong><code>if (!modelExists) { ... }</code></strong>: Model ID'si geçersizse, uyarı loglar ve varsayılan ilk AI modelini kullanmaya çalışır. Fallback de başarısız olursa hata loglar ve <code>null</code> döner.</li>
                    </ul>
                    <p><strong><code>const newChat = { ... };</code></strong>: Yeni sohbet için bir obje oluşturur. Bu obje şunları içerir:</p>
                    <ul>
                        <li><strong><code>id</code></strong>: Zaman damgası ve rastgele bir string içeren benzersiz bir sohbet ID'si.</li>
                        <li><strong><code>aiModelId</code></strong>: Belirlenen (veya varsayılan) yapay zeka modelinin ID'si.</li>
                        <li><strong><code>messages: []</code></strong>: Sohbet mesajlarını tutacak boş bir dizi.</li>
                        <li><strong><code>createdAt</code></strong>: Sohbetin oluşturulma zaman damgası.</li>
                        <li><strong><code>lastActivity</code></strong>: Son aktivite zaman damgası (başlangıçta oluşturulma zamanı).</li>
                        <li><strong><code>isMinimized: false</code></strong>: Sohbetin küçültülmüş olup olmadığını belirten bayrak (başlangıçta değil).</li>
                        <li><strong><code>inputHistory: []</code></strong>: Kullanıcının girdiği mesajları hatırlamak için (yukarı/aşağı ok tuşlarıyla) kullanılacak bir dizi.</li>
                        <li><strong><code>historyIndex: -1</code></strong>: <code>inputHistory</code>'deki mevcut konumu izlemek için.</li>
                    </ul>
                    <p><strong><code>state.chats.push(newChat);</code></strong>: Oluşturulan yeni sohbet objesini <code>state.chats</code> dizisine ekler.</p>
                    <p><strong><code>log('info', 'New chat added:', ...);</code></strong>: Yeni sohbetin eklendiğini ve verilerini (derin kopya) loglar.</p>
                    <p><strong><code>renderChats(); renderActiveChatsDropdown();</code></strong>: Arayüzü güncellemek için ilgili render fonksiyonlarını çağırır.</p>
                    <p><strong><code>const newChatElement = elements.chatContainer.querySelector(...);</code></strong>: Yeni eklenen sohbetin DOM elemanını bulur.</p>
                    <p><strong><code>if (newChatElement) { ... }</code></strong>: Eleman bulunursa:</p>
                    <ul>
                        <li><strong><code>const inputField = newChatElement.querySelector('.chat-input');</code></strong>: Sohbetin mesaj giriş alanını bulur.</li>
                        <li><strong><code>if (inputField && newChatElement.offsetParent !== null) { inputField.focus(); }</code></strong>: Giriş alanı varsa ve sohbet penceresi görünür durumdaysa (<code>offsetParent !== null</code> basit bir görünürlük kontrolüdür), giriş alanına odaklanır.</li>
                    </ul>
                    <p><strong><code>return newChat.id;</code></strong>: Başarıyla oluşturulan yeni sohbetin ID'sini döndürür.</p>
                </div>
            </details>

            <h4 class="text-lg font-semibold text-gray-700 mt-6">Fonksiyon: <code>removeChat(chatId)</code></h4>
            <div class="code-block">
function removeChat(chatId) {
    log('action', 'Attempting to remove chat', chatId);
    const chatWindow = document.querySelector(\`.chat-window[data-chat-id="${chatId}"]\`);

    if (chatWindow) {
        chatWindow.classList.add('closing'); 

        const handleAnimationEnd = () => {
            const chatIndex = state.chats.findIndex(chat => chat.id === chatId);
            if (chatIndex !== -1) {
                const chatToRemove = state.chats[chatIndex];
                const hasUserMessages = chatToRemove.messages && chatToRemove.messages.some(msg => msg.isUser);

                if (hasUserMessages) {
                    log('info', \`Chat ${chatId} has user messages. Moving to history.\`);
                    chatToRemove.closedTimestamp = Date.now(); 
                    if (!Array.isArray(state.chatHistory)) {
                        state.chatHistory = [];
                    }
                    state.chatHistory.unshift(chatToRemove); 
                } else {
                    log('info', \`Chat ${chatId} has no user messages. Removing without adding to history.\`);
                }
                state.chats.splice(chatIndex, 1);

                if (chatWindow.parentNode) {
                    chatWindow.parentNode.removeChild(chatWindow);
                }
                
                renderChats(); 
                renderActiveChatsDropdown();
                if (typeof renderChatHistory === 'function') {
                    renderChatHistory(); 
                }
            } else { /* ... */ }
        };

        chatWindow.addEventListener('animationend', handleAnimationEnd, { once: true });

        setTimeout(() => { // Güvenlik önlemi
            if (chatWindow.parentNode && chatWindow.classList.contains('closing')) {
                // ... (animasyon zaman aşımına uğrarsa zorla kaldırma)
            }
        }, 700); 

    } else {
        // ... (sohbet penceresi DOM'da bulunamazsa doğrudan state'den kaldırma)
    }
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>log('action', ...);</code></strong>: Bir sohbeti kaldırma girişimini loglar.</p>
                    <p><strong><code>const chatWindow = document.querySelector(...);</code></strong>: Kaldırılacak sohbetin DOM elemanını <code>data-chat-id</code> niteliğiyle bulur.</p>
                    <p><strong><code>if (chatWindow) { ... }</code></strong>: Sohbet penceresi DOM'da bulunursa:</p>
                    <ul>
                        <li><strong><code>chatWindow.classList.add('closing');</code></strong>: Pencereye bir kapanış animasyonu başlatmak için <code>closing</code> CSS sınıfını ekler.</li>
                        <li><strong><code>const handleAnimationEnd = () => { ... };</code></strong>: Animasyon bittiğinde çalışacak bir fonksiyon tanımlar.</li>
                        <ul>
                            <li><strong><code>const chatIndex = state.chats.findIndex(...);</code></strong>: Kaldırılacak sohbetin <code>state.chats</code> dizisindeki indeksini bulur.</li>
                            <li><strong><code>if (chatIndex !== -1) { ... }</code></strong>: Sohbet state'de bulunursa:</li>
                            <ul>
                                <li><strong><code>const chatToRemove = state.chats[chatIndex];</code></strong>: Kaldırılacak sohbetin verilerini alır.</li>
                                <li><strong><code>const hasUserMessages = ...;</code></strong>: Sohbette kullanıcı mesajı olup olmadığını kontrol eder.</li>
                                <li><strong><code>if (hasUserMessages) { ... }</code></strong>: Kullanıcı mesajı varsa, sohbeti geçmişe taşır (<code>closedTimestamp</code> ekler ve <code>state.chatHistory</code> dizisinin başına ekler).</li>
                                <li><strong><code>state.chats.splice(chatIndex, 1);</code></strong>: Sohbeti aktif sohbetler (<code>state.chats</code>) dizisinden kaldırır.</li>
                                <li><strong><code>if (chatWindow.parentNode) { chatWindow.parentNode.removeChild(chatWindow); }</code></strong>: Sohbet penceresini DOM'dan kaldırır.</li>
                                <li><strong><code>renderChats(); renderActiveChatsDropdown(); renderChatHistory();</code></strong>: Arayüzü günceller.</li>
                            </ul>
                        </ul>
                        <li><strong><code>chatWindow.addEventListener('animationend', handleAnimationEnd, { once: true });</code></strong>: <code>animationend</code> olayı için bir dinleyici ekler. <code>{ once: true }</code> sayesinde olay bir kez tetiklendikten sonra dinleyici otomatik olarak kaldırılır.</li>
                        <li><strong><code>setTimeout(() => { ... }, 700);</code></strong>: Bir güvenlik önlemi olarak, eğer <code>animationend</code> olayı belirli bir süre (700ms) içinde tetiklenmezse (CSS animasyonuyla ilgili bir sorun olabilir), sohbeti zorla kaldırır.</li>
                    </ul>
                    <p><strong><code>else { ... }</code></strong>: Sohbet penceresi DOM'da bulunamazsa (bu beklenmedik bir durumdur), sohbeti doğrudan state'den (ve varsa geçmişe taşıyarak) kaldırmaya çalışır ve arayüzü günceller.</p>
                </div>
            </details>

            <h4 class="text-lg font-semibold text-gray-700 mt-6">Fonksiyon: <code>clearAllChats()</code></h4>
            <div class="code-block">
function clearAllChats() {
    log('action', 'Clearing unused chats');

    const initialChatCount = state.chats.length;
    if (initialChatCount === 0) {
        log('info', 'No chats to clear.');
        return; 
    }

    state.chats = state.chats.filter(chat => {
        const hasUserMessage = chat.messages && chat.messages.some(msg => msg.isUser);
        return hasUserMessage; 
    });

    const chatsRemovedCount = initialChatCount - state.chats.length;

    if (chatsRemovedCount > 0) {
        log('info', \`${chatsRemovedCount} unused chat(s) removed.\`);
        renderChats();
        renderActiveChatsDropdown();
    } else {
        log('info', 'No unused chats were found to remove (all chats have conversations).');
    }
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>log('action', 'Clearing unused chats');</code></strong>: Kullanılmayan sohbetleri temizleme işleminin başladığını loglar.</p>
                    <p><strong><code>const initialChatCount = state.chats.length;</code></strong>: İşlem öncesindeki toplam sohbet sayısını saklar.</p>
                    <p><strong><code>if (initialChatCount === 0) { ... }</code></strong>: Eğer hiç sohbet yoksa, bilgi loglar ve fonksiyondan çıkar.</p>
                    <p><strong><code>state.chats = state.chats.filter(chat => { ... });</code></strong>: <code>state.chats</code> dizisini yeniden filtreler. Sadece kullanıcı mesajı içeren (<code>hasUserMessage</code> true olan) sohbetleri tutar, diğerlerini (kullanılmamış olanları) diziden çıkarır.</p>
                    <ul>
                        <li><strong><code>const hasUserMessage = chat.messages && chat.messages.some(msg => msg.isUser);</code></strong>: Belirli bir sohbetin kullanıcı mesajı içerip içermediğini kontrol eder.</li>
                        <li><strong><code>return hasUserMessage;</code></strong>: Filtreleme koşulu; <code>true</code> ise sohbet korunur, <code>false</code> ise çıkarılır.</li>
                    </ul>
                    <p><strong><code>const chatsRemovedCount = initialChatCount - state.chats.length;</code></strong>: Kaldırılan sohbet sayısını hesaplar.</p>
                    <p><strong><code>if (chatsRemovedCount > 0) { ... }</code></strong>: Eğer en az bir sohbet kaldırıldıysa, kaldırılan sohbet sayısını loglar ve arayüzü (<code>renderChats</code>, <code>renderActiveChatsDropdown</code>) günceller.</p>
                    <p><strong><code>else { ... }</code></strong>: Eğer hiç kullanılmamış sohbet bulunup kaldırılmadıysa, bu durumu loglar.</p>
                </div>
            </details>
        </section>

        <section class="function-section" id="messaging-system">
            <h3 class="text-xl function-title-text mb-3">5.2 Mesajlaşma Sistemi (Messaging System)</h3>
            <p class="text-gray-600 mb-4">Bu alt bölüm, kullanıcı mesajlarının gönderilmesi ve yapay zeka yanıtlarının alınmasıyla ilgili fonksiyonu içerir.</p>

            <h4 class="text-lg font-semibold text-gray-700 mt-4">Fonksiyon: <code>sendMessage(chatId, text)</code></h4>
            <div class="code-block">
async function sendMessage(chatId, text) {
    log('action', 'Sending message', chatId, text);

    const chat = state.chats.find(c => c.id === chatId);
    if (!chat) { /* ... */ return; }

    const userMessage = { isUser: true, text: text, timestamp: Date.now() };
    chat.messages.push(userMessage);
    chat.lastActivity = Date.now();
    const isUsersFirstMessageInChat = chat.messages.filter(m => m.isUser).length === 1;

    const chatElement = document.querySelector(\`.chat-window[data-chat-id="\${chatId}"]\`);
    if (chatElement) {
        // ... (Kullanıcı mesajını UI'a ekleme ve model kilitleme mantığı)
    }

    // Yükleniyor göstergesi ekleme
    let loadingElement = null;
    // ... (Yükleniyor göstergesi için HTML oluşturma ve UI'a ekleme)

    try {
        const fullConversationForAPI = chat.messages
            .filter(msg => msg.isUser || (msg.text && typeof msg.text === 'string' && msg.text.trim() !== ''))
            .map(msg => ({
                role: msg.isUser ? 'user' : 'model',
                parts: [{ text: msg.text.trim() }]
            }));

        const response = await fetch('/api/chat/send', { 
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chatId: chatId,
                message: text, 
                aiModelId: chat.aiModelId,
                history: fullConversationForAPI, 
            }),
        });

        if (!response.ok) { /* ... (Hata yönetimi) ... */ throw new Error(errorText); }

        const data = await response.json();
        const aiResponseText = data.response; 

        // Yükleniyor göstergesini kaldır ve yanıtı ekle
        if (loadingElement && loadingElement.parentNode) {
            // ... (AI yanıtını state'e ve UI'a ekleme)
        } else { /* ... */ }

    } catch (error) {
        log('error', 'Failed to send message or get AI response:', error);
        // ... (Yükleniyor göstergesini kaldır ve hata mesajını UI'a ekleme)
    } finally {
        renderActiveChatsDropdown();
    }
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları (Özetlenmiş)</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>async function sendMessage(chatId, text)</code></strong>: Fonksiyon asenkron olarak tanımlanmıştır çünkü backend'e API isteği yapacaktır (<code>await fetch</code>).</p>
                    <p><strong><code>const chat = state.chats.find(c => c.id === chatId);</code></strong>: Mesajın gönderileceği sohbeti ID'si ile bulur.</p>
                    <p><strong><code>const userMessage = { ... }; chat.messages.push(userMessage);</code></strong>: Kullanıcının mesajını bir obje olarak oluşturur ve sohbetin <code>messages</code> dizisine ekler. <code>lastActivity</code> güncellenir.</p>
                    <p><strong><code>const isUsersFirstMessageInChat = ...;</code></strong>: Bu mesajın kullanıcının sohbetteki ilk mesajı olup olmadığını kontrol eder (model kilitleme için).</p>
                    <p><strong><code>if (chatElement) { ... }</code></strong>: Sohbet penceresi DOM'da bulunursa, kullanıcı mesajını UI'da gösterir ve eğer bu ilk kullanıcı mesajıysa, model seçimi UI'ını kilitler.</p>
                    <p><strong>Yükleniyor Göstergesi:</strong> AI yanıtı beklenirken UI'da bir "yükleniyor..." mesajı (noktalarla birlikte) gösterilir. Bu, <code>loadingElement</code> ile yönetilir.</p>
                    <p><strong><code>try { ... } catch (error) { ... } finally { ... }</code></strong>: API isteği ve yanıt işleme bir <code>try...catch</code> bloğu içine alınır.</p>
                    <ul>
                        <li><strong><code>const fullConversationForAPI = chat.messages.map(...);</code></strong>: Sohbet geçmişini (kullanıcı ve model mesajlarını) backend API'sinin beklediği formata (<code>role</code> ve <code>parts</code> içeren objeler dizisi) dönüştürür.</li>
                        <li><strong><code>const response = await fetch('/api/chat/send', { ... });</code></strong>: Backend'e (<code>/api/chat/send</code> endpoint'ine) bir POST isteği gönderir. İstek gövdesi (body) şunları içerir: <code>chatId</code>, son kullanıcı <code>message</code>'ı, <code>aiModelId</code> ve formatlanmış <code>history</code>.
                            <div class="api-call">
                                <strong>API Çağrısı:</strong> Bu komut, sunucu tarafındaki bir yapay zeka servisiyle iletişim kurar. Sunucu, sağlanan konuşma geçmişi ve model ID'sine göre bir yanıt üretir.
                            </div>
                        </li>
                        <li><strong><code>if (!response.ok) { ... }</code></strong>: Eğer API yanıtı başarılı değilse (HTTP durum kodu 2xx değilse), bir hata oluşturulur ve <code>catch</code> bloğuna atlanır.</li>
                        <li><strong><code>const data = await response.json(); const aiResponseText = data.response;</code></strong>: Başarılı yanıttan JSON verisini alır ve yapay zeka yanıt metnini (<code>data.response</code>) çıkarır.</li>
                        <li>Yükleniyor göstergesi kaldırılır ve alınan AI yanıtı state'e ve UI'a eklenir.</li>
                    </ul>
                    <p><strong><code>catch (error) { ... }</code></strong>: API isteği sırasında veya yanıt işlenirken bir hata oluşursa, bu blok çalışır. Hata loglanır ve UI'da bir hata mesajı gösterilir (yükleniyor göstergesinin yerine).</p>
                    <p><strong><code>finally { renderActiveChatsDropdown(); }</code></strong>: İşlem başarılı olsun ya da olmasın, <code>finally</code> bloğu her zaman çalışır ve aktif sohbetler açılır menüsünü günceller.</p>
                </div>
            </details>
        </section>

        <section class="function-section" id="broadcast-messages">
            <h3 class="text-xl function-title-text mb-3">5.3 Yayın Mesajları (Broadcast Messages)</h3>
            <p class="text-gray-600 mb-4">Bu alt bölüm, tüm aktif (küçültülmemiş) sohbetlere aynı mesajın gönderilmesini sağlayan fonksiyonu içerir.</p>

            <h4 class="text-lg font-semibold text-gray-700 mt-4">Fonksiyon: <code>sendBroadcastMessage()</code></h4>
            <div class="code-block">
function sendBroadcastMessage() {
    if (!elements.broadcastMessageInput) {
        log('warn', 'Broadcast message input not found.');
        return;
    }
    const messageText = elements.broadcastMessageInput.value.trim();

    if (messageText === '') {
        log('info', 'Broadcast message is empty, not sending.');
        return;
    }

    log('action', \`Attempting to broadcast message: "\${messageText}"\`);

    const activeChats = state.chats.filter(chat => !chat.isMinimized);

    if (activeChats.length === 0) {
        log('info', 'No active (non-minimized) chats to broadcast to.');
        alert('There are no active chats to send a message to. Create a new chat or restore a minimized one.');
        return;
    }

    activeChats.forEach(chat => {
        log('debug', \`Sending broadcast message to chat ID: \${chat.id}\`);
        sendMessage(chat.id, messageText); 
    });

    elements.broadcastMessageInput.value = ''; 
    log('info', 'Broadcast message sent and input cleared.');
}
            </div>
            <details class="mt-2">
                <summary class="explanation-summary">
                    <span>Komut Açıklamaları</span>
                    <span class="chevron"></span>
                </summary>
                <div class="explanation-details">
                    <p><strong><code>if (!elements.broadcastMessageInput) { ... }</code></strong>: Yayın mesajı giriş alanının DOM'da olup olmadığını kontrol eder. Yoksa uyarı loglar ve çıkar.</p>
                    <p><strong><code>const messageText = elements.broadcastMessageInput.value.trim();</code></strong>: Giriş alanındaki metni alır ve başındaki/sonundaki boşlukları temizler.</p>
                    <p><strong><code>if (messageText === '') { ... }</code></strong>: Eğer mesaj metni boşsa, bilgi loglar ve göndermeden çıkar.</p>
                    <p><strong><code>log('action', ...);</code></strong>: Yayın mesajı gönderme girişimini ve mesaj metnini loglar.</p>
                    <p><strong><code>const activeChats = state.chats.filter(chat => !chat.isMinimized);</code></strong>: Aktif (küçültülmemiş) sohbetleri filtreler.</p>
                    <p><strong><code>if (activeChats.length === 0) { ... }</code></strong>: Eğer yayın yapılacak aktif sohbet yoksa, bilgi loglar, kullanıcıya bir uyarı (alert) gösterir ve çıkar.</p>
                    <p><strong><code>activeChats.forEach(chat => { ... });</code></strong>: Her bir aktif sohbet için bir döngü başlatır.</p>
                    <ul>
                        <li><strong><code>log('debug', ...);</code></strong>: Mesajın hangi sohbete gönderildiğini loglar.</li>
                        <li><strong><code>sendMessage(chat.id, messageText);</code></strong>: Her bir aktif sohbet için <code>sendMessage</code> fonksiyonunu çağırarak yayın mesajını gönderir. Bu, her sohbet için ayrı bir AI etkileşimi başlatacaktır (eğer <code>sendMessage</code> AI yanıtı bekliyorsa).</li>
                    </ul>
                    <p><strong><code>elements.broadcastMessageInput.value = '';</code></strong>: Yayın mesajı giriş alanını temizler.</p>
                    <p><strong><code>log('info', 'Broadcast message sent and input cleared.');</code></strong>: Yayın mesajının gönderildiğini ve giriş alanının temizlendiğini loglar.</p>
                </div>
            </details>
        </section>

    </div>
</body>
</html>
